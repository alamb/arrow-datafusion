# Test for grouped by table


# Columns in the table are a,b,c,d. Source is CsvExec which is ordered by
# a,b,c column. Column a has cardinality 2, column b has cardinality 4.
# Column c has cardinality 100 (unique entries). Column d has cardinality 5.
statement ok
CREATE UNBOUNDED EXTERNAL TABLE t (
  a0 INTEGER,
  a INTEGER,
  b INTEGER,
  c INTEGER,
  d INTEGER
)
STORED AS CSV
WITH HEADER ROW
WITH ORDER (a ASC, b ASC, c ASC)
LOCATION 'tests/data/window_2.csv';


# Show that it uses bounded aggregate stream...
query TT
EXPLAIN
SELECT a, SUM(b)
FROM t
GROUP BY a;
----
logical_plan
Aggregate: groupBy=[[t.a]], aggr=[[SUM(t.b)]]
--TableScan: t projection=[a, b]
physical_plan
AggregateExec: mode=FinalPartitioned, gby=[a@0 as a], aggr=[SUM(t.b)], ordering_mode=FullyOrdered
--CoalesceBatchesExec: target_batch_size=8192
----RepartitionExec: partitioning=Hash([a@0], 4), input_partitions=1
------AggregateExec: mode=Partial, gby=[a@0 as a], aggr=[SUM(t.b)], ordering_mode=FullyOrdered
--------CsvExec: file_groups={1 group: [[WORKSPACE_ROOT/datafusion/core/tests/data/window_2.csv]]}, projection=[a, b], infinite_source=true, output_ordering=[a@0 ASC NULLS LAST, b@1 ASC NULLS LAST], has_header=true

query IIII
select a, b, c, d from t;
----
0 0 0 0
0 0 1 2
0 0 2 0
0 0 3 0
0 0 4 1
0 0 5 1
0 0 6 0
0 0 7 2
0 0 8 1
0 0 9 4
0 0 10 4
0 0 11 2
0 0 12 2
0 0 13 1
0 0 14 2
0 0 15 3
0 0 16 3
0 0 17 2
0 0 18 1
0 0 19 4
0 0 20 0
0 0 21 3
0 0 22 0
0 0 23 0
0 0 24 4
0 1 25 0
0 1 26 2
0 1 27 0
0 1 28 1
0 1 29 1
0 1 30 3
0 1 31 4
0 1 32 2
0 1 33 2
0 1 34 4
0 1 35 0
0 1 36 1
0 1 37 4
0 1 38 0
0 1 39 1
0 1 40 1
0 1 41 3
0 1 42 3
0 1 43 2
0 1 44 3
0 1 45 0
0 1 46 0
0 1 47 1
0 1 48 1
0 1 49 3
1 2 50 0
1 2 51 3
1 2 52 1
1 2 53 1
1 2 54 4
1 2 55 2
1 2 56 1
1 2 57 1
1 2 58 1
1 2 59 2
1 2 60 4
1 2 61 3
1 2 62 1
1 2 63 4
1 2 64 4
1 2 65 0
1 2 66 2
1 2 67 4
1 2 68 1
1 2 69 1
1 2 70 0
1 2 71 2
1 2 72 1
1 2 73 1
1 2 74 4
1 3 75 2
1 3 76 0
1 3 77 2
1 3 78 1
1 3 79 4
1 3 80 2
1 3 81 0
1 3 82 4
1 3 83 2
1 3 84 1
1 3 85 1
1 3 86 1
1 3 87 4
1 3 88 3
1 3 89 4
1 3 90 1
1 3 91 2
1 3 92 0
1 3 93 0
1 3 94 2
1 3 95 0
1 3 96 4
1 3 97 2
1 3 98 4
1 3 99 3

# Force incremental output
statement ok
set datafusion.execution.batch_size = 8;

# # Run it
# query II rowsort
# SELECT a, COUNT(b)
# FROM t
# GROUP BY a;
# ----
# 0 50
# 1 50


# # Run it
# query II rowsort
# SELECT a, SUM(b)
# FROM t
# GROUP BY a;
# ----
# 0 25
# 1 125

# use partial grouping (data sorted on a, b, c but group by d, a)

# Run it
query III rowsort
SELECT d, a, COUNT(b)
FROM t
GROUP BY d, a;
----
0 0 13
0 1 8
1 0 12
1 1 15
2 0 10
2 1 11
3 0 8
3 1 4
4 0 7
4 1 12



# Run it
query III rowsort
SELECT d, a, SUM(b)
FROM t
GROUP BY d, a;
----
0 0 6
0 1 21
1 0 7
1 1 35
2 0 4
2 1 29
3 0 5
3 1 10
4 0 3
4 1 30


# verify
statement ok
create table t2 as select * from t;


# Run it
query III rowsort
SELECT d, a, COUNT(b)
FROM t2
GROUP BY d, a;
----
0 0 13
0 1 8
1 0 12
1 1 15
2 0 10
2 1 11
3 0 8
3 1 4
4 0 7
4 1 12



# Run it
query III rowsort
SELECT d, a, SUM(b)
FROM t2
GROUP BY d, a;
----
0 0 6
0 1 21
1 0 7
1 1 35
2 0 4
2 1 29
3 0 5
3 1 10
4 0 3
4 1 30
