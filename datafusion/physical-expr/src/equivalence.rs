// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

use crate::expressions::Column;
use crate::utils::get_indices_of_exprs_strict;
use crate::{
    physical_exprs_contains, reverse_order_bys, LexOrdering, LexOrderingRef,
    LexOrderingReq, PhysicalExpr, PhysicalSortExpr, PhysicalSortRequirement,
};

use arrow::datatypes::SchemaRef;

use crate::physical_expr::{deduplicate_physical_exprs, have_common_entries};
use crate::sort_properties::{ExprOrdering, SortProperties};
use arrow_schema::SortOptions;
use datafusion_common::tree_node::{Transformed, TreeNode};
use datafusion_common::utils::longest_consecutive_prefix;
use datafusion_common::{DataFusionError, JoinSide, JoinType, Result};
use itertools::izip;
use std::hash::Hash;
use std::ops::Range;
use std::sync::Arc;

/// EquivalentClass is a set of [`Arc<dyn PhysicalExpr>`]s that are known
/// to have the same value in all tuples in a relation. These are generated by equality predicates,
/// typically equi-join conditions and equality conditions in filters.
#[derive(Debug, Clone)]
pub struct EquivalentGroups {
    inner: Vec<Vec<Arc<dyn PhysicalExpr>>>,
}

impl EquivalentGroups {
    /// Creates an empty ordering equivalent group
    fn empty() -> Self {
        EquivalentGroups { inner: vec![] }
    }

    /// Creates ordering equivalent groups from given vectors
    /// Each vector corresponds to a group
    fn new(entries: Vec<Vec<Arc<dyn PhysicalExpr>>>) -> Self {
        let mut res = EquivalentGroups { inner: entries };
        res.remove_redundant_entries();
        res
    }

    /// Get how many equivalent groups there are.
    fn len(&self) -> usize {
        self.inner.len()
    }

    /// Check whether equivalent groups is empty
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn iter(&self) -> impl Iterator<Item = &Vec<Arc<dyn PhysicalExpr>>> {
        self.inner.iter()
    }

    #[allow(dead_code)]
    fn into_iter(self) -> impl Iterator<Item = Vec<Arc<dyn PhysicalExpr>>> {
        self.inner.into_iter()
    }

    /// Adds tuple argument to the equivalent groups
    /// It is known that first and second entry in the tuple will have same values in the table.
    /// This can arise after filter(a=b), alias(a, a as b), etc.
    pub fn add_equal_conditions(
        &mut self,
        new_conditions: (&Arc<dyn PhysicalExpr>, &Arc<dyn PhysicalExpr>),
    ) {
        let (first, second) = new_conditions;
        let mut first_group = None;
        let mut second_group = None;
        for (group_idx, eq_class) in self.inner.iter().enumerate() {
            if physical_exprs_contains(eq_class, first) {
                first_group = Some(group_idx);
            }
            if physical_exprs_contains(eq_class, second) {
                second_group = Some(group_idx);
            }
        }
        match (first_group, second_group) {
            (Some(first_group_idx), Some(second_group_idx)) => {
                // We should bridge these groups
                if first_group_idx != second_group_idx {
                    let other_class = self.inner[second_group_idx].clone();
                    // TODO: Use group at the lower index during merging
                    // This would improve performance during remove.
                    self.inner[first_group_idx].extend(other_class);
                    self.inner.remove(second_group_idx);
                }
            }
            (Some(group_idx), None) => {
                // Extend existing group with new entry
                self.inner[group_idx].push(second.clone());
            }
            (None, Some(group_idx)) => {
                // Extend existing group with new entry
                self.inner[group_idx].push(first.clone());
            }
            (None, None) => {
                // None of the expressions, is among existing groups
                // Create a new group.
                self.inner.push(vec![first.clone(), second.clone()]);
            }
        }
        self.remove_redundant_entries();
    }

    /// Remove redundant entries from the state.
    fn remove_redundant_entries(&mut self) {
        // Remove duplicate entries from each group.
        self.inner = self
            .inner
            .iter()
            .filter_map(|eq_group| {
                let unique_eq_group = deduplicate_physical_exprs(eq_group);
                // Keep groups that have at least 2 entries
                (unique_eq_group.len() > 1).then_some(unique_eq_group)
            })
            .collect();
        // Bridge groups that have common expressions
        self.bridge_groups()
    }

    /// This utils bridges groups that have common expressions
    fn bridge_groups(&mut self) {
        let mut out_groups = vec![];
        for group in &self.inner {
            if out_groups.is_empty() {
                out_groups.push(group.clone());
            } else {
                let mut bridged_group = group.clone();
                // Delete groups in the `out_groups` that have common entry with `group`.
                // Append deleted groups to the `bridged_group`
                out_groups.retain(|distinct_group| {
                    let have_common = have_common_entries(distinct_group, group);
                    if have_common {
                        bridged_group.extend(distinct_group.clone());
                    }
                    !have_common
                });
                // before inserting make sure that entries are deduplicated
                let bridged_group = deduplicate_physical_exprs(&bridged_group);
                out_groups.push(bridged_group);
            }
        }
        self.inner = out_groups;
    }

    /// Extend equivalent group with other equivalent groups
    fn extend(&mut self, other: EquivalentGroups) {
        self.inner.extend(other.inner);
        self.remove_redundant_entries();
    }

    /// Normalizes physical expression according to `EquivalentClass`es inside `self.classes`.
    /// expression is replaced with `EquivalentClass::head` expression if it is among `EquivalentClass::others`.
    pub fn normalize_expr(&self, expr: Arc<dyn PhysicalExpr>) -> Arc<dyn PhysicalExpr> {
        expr.clone()
            .transform(&|expr| {
                for class in self.iter() {
                    if physical_exprs_contains(class, &expr) {
                        return Ok(Transformed::Yes(class[0].clone()));
                    }
                }
                Ok(Transformed::No(expr))
            })
            .unwrap_or(expr)
    }

    /// This function applies the \[`normalize_expr`]
    /// function for all expression in `exprs` and returns a vector of
    /// normalized physical expressions.
    pub fn normalize_exprs(
        &self,
        exprs: &[Arc<dyn PhysicalExpr>],
    ) -> Vec<Arc<dyn PhysicalExpr>> {
        exprs
            .iter()
            .map(|expr| self.normalize_expr(expr.clone()))
            .collect::<Vec<_>>()
    }

    /// This function normalizes `sort_requirement` according to `EquivalenceClasses` in the `self`.
    /// If the given sort requirement doesn't belong to equivalence set inside
    /// `self`, it returns `sort_requirement` as is.
    pub fn normalize_sort_requirement(
        &self,
        mut sort_requirement: PhysicalSortRequirement,
    ) -> PhysicalSortRequirement {
        sort_requirement.expr = self.normalize_expr(sort_requirement.expr);
        sort_requirement
    }

    /// This function normalizes `sort_requirement` according to `EquivalenceClasses` in the `self`.
    /// If the given sort requirement doesn't belong to equivalence set inside
    /// `self`, it returns `sort_requirement` as is.
    pub fn normalize_sort_expr(
        &self,
        mut sort_expr: PhysicalSortExpr,
    ) -> PhysicalSortExpr {
        sort_expr.expr = self.normalize_expr(sort_expr.expr);
        sort_expr
    }

    /// This function applies the \[`normalize_sort_requirement`]
    /// function for all sort requirements in `sort_reqs` and returns a vector of
    /// normalized sort expressions.
    pub fn normalize_sort_requirements(
        &self,
        sort_reqs: &[PhysicalSortRequirement],
    ) -> Vec<PhysicalSortRequirement> {
        let normalized_sort_reqs = sort_reqs
            .iter()
            .map(|sort_req| self.normalize_sort_requirement(sort_req.clone()))
            .collect::<Vec<_>>();
        collapse_lex_req(normalized_sort_reqs)
    }

    /// Similar to the \[`normalize_sort_requirements`] this function normalizes
    /// sort expressions in `sort_exprs` and returns a vector of
    /// normalized sort expressions.
    pub fn normalize_sort_exprs(
        &self,
        sort_exprs: &[PhysicalSortExpr],
    ) -> Vec<PhysicalSortExpr> {
        // Convert `PhysicalSortExpr`s to `PhysicalSortRequirement`s
        let sort_requirements =
            PhysicalSortRequirement::from_sort_exprs(sort_exprs.iter());
        let normalized_sort_requirement =
            self.normalize_sort_requirements(&sort_requirements);
        // Convert back `PhysicalSortRequirement`s to `PhysicalSortExpr`s
        PhysicalSortRequirement::to_sort_exprs(normalized_sort_requirement)
    }

    /// Projects given expression according to mapping in the `source_to_target_mapping`.
    /// If expression is not valid after projection returns `None`.
    fn project_expr(
        &self,
        source_to_target_mapping: &ProjectionMapping,
        expr: &Arc<dyn PhysicalExpr>,
    ) -> Option<Arc<dyn PhysicalExpr>> {
        let children = expr.children();
        if children.is_empty() {
            for (source, target) in source_to_target_mapping.iter() {
                // if source matches expr, expr can be projected
                if source.eq(expr) {
                    return Some(target.clone());
                }
                // if equivalent group of source contains expr, expr can be projected
                else if let Some(group) = self.get_equivalent_group(source) {
                    if physical_exprs_contains(&group, expr) {
                        return Some(target.clone());
                    }
                }
            }
            // After projection, expression is not valid.
            None
        }
        // All of the childrens can be projected
        else if let Some(children) = children
            .into_iter()
            .map(|child| self.project_expr(source_to_target_mapping, &child))
            .collect::<Option<Vec<_>>>()
        {
            Some(expr.clone().with_new_children(children).unwrap())
        } else {
            None
        }
    }

    /// Projects given ordering according to mapping in the `source_to_target_mapping`.
    /// If ordering is not valid after projection returns `None`.
    fn project_ordering(
        &self,
        source_to_target_mapping: &ProjectionMapping,
        ordering: &[PhysicalSortExpr],
    ) -> Option<Vec<PhysicalSortExpr>> {
        let mut res = vec![];
        for order in ordering {
            if let Some(new_expr) =
                self.project_expr(source_to_target_mapping, &order.expr)
            {
                res.push(PhysicalSortExpr {
                    expr: new_expr,
                    options: order.options,
                })
            } else {
                // Expression is not valid, rest of the ordering shouldn't be projected also.
                // e.g if input ordering is [a ASC, b ASC, c ASC], and column b is not valid
                // after projection
                // we should return projected ordering as [a ASC] not as [a ASC, c ASC] even if
                // column c is valid after projection.
                break;
            }
        }
        if res.is_empty() {
            None
        } else {
            Some(res)
        }
    }

    /// Construct equivalent groups according to projection mapping.
    /// In the result, each inner vector contains equivalents sets. Outer vector corresponds to
    /// distinct equivalent groups
    fn calculate_new_projection_equivalent_groups(
        source_to_target_mapping: &ProjectionMapping,
    ) -> Vec<Vec<Arc<dyn PhysicalExpr>>> {
        // TODO: Convert below algorithm to the version that use HashMap.
        //  once `Arc<dyn PhysicalExpr>` can be stored in `HashMap`.
        let mut res = vec![];
        for (source, target) in source_to_target_mapping {
            if res.is_empty() {
                res.push((source, vec![target.clone()]));
            }
            if let Some(idx) = res.iter_mut().position(|(key, _values)| key.eq(source)) {
                let (_, values) = &mut res[idx];
                if !physical_exprs_contains(values, target) {
                    values.push(target.clone());
                }
            }
        }

        // Filter out groups with single entry, there is nothing
        // else equal to these expressions. Hence tracking them is meaningless
        res.into_iter()
            .filter_map(|(_key, values)| (values.len() > 1).then_some(values))
            .collect()
    }

    /// Projects EquivalentGroups according to projection mapping described in `source_to_target_mapping`.
    pub fn project(
        &self,
        source_to_target_mapping: &ProjectionMapping,
    ) -> EquivalentGroups {
        let mut new_eq_classes = vec![];
        for eq_class in self.iter() {
            let new_eq_class = eq_class
                .iter()
                .filter_map(|expr| self.project_expr(source_to_target_mapping, expr))
                .collect::<Vec<_>>();
            if new_eq_class.len() > 1 {
                new_eq_classes.push(new_eq_class.clone());
            }
        }
        let new_classes =
            Self::calculate_new_projection_equivalent_groups(source_to_target_mapping);
        new_eq_classes.extend(new_classes);

        let mut projection_eq_groups = EquivalentGroups::new(new_eq_classes);
        // Make sure there is no redundant entry after projection.
        projection_eq_groups.remove_redundant_entries();
        projection_eq_groups
    }

    /// Returns the equivalent group that contains `expr`
    /// If none of the groups contains `expr`, returns None.
    fn get_equivalent_group(
        &self,
        expr: &Arc<dyn PhysicalExpr>,
    ) -> Option<Vec<Arc<dyn PhysicalExpr>>> {
        for eq_class in self.iter() {
            if physical_exprs_contains(eq_class, expr) {
                return Some(eq_class.to_vec());
            }
        }
        None
    }

    /// Combine EquivalentGroups of the given join children.
    pub fn join(
        &self,
        join_type: &JoinType,
        right_eq_classes: &EquivalentGroups,
        left_columns_len: usize,
        on: &[(Column, Column)],
    ) -> Result<EquivalentGroups> {
        let mut res = EquivalentGroups::empty();
        match join_type {
            JoinType::Inner | JoinType::Left | JoinType::Full | JoinType::Right => {
                res.extend(self.clone());
                let updated_eq_classes = right_eq_classes
                    .iter()
                    .map(|eq_class| {
                        add_offset_to_exprs(eq_class.to_vec(), left_columns_len)
                    })
                    .collect::<Result<Vec<_>>>()?;

                res.extend(EquivalentGroups::new(updated_eq_classes));
            }
            JoinType::LeftSemi | JoinType::LeftAnti => {
                res.extend(self.clone());
            }
            JoinType::RightSemi | JoinType::RightAnti => {
                res.extend(right_eq_classes.clone());
            }
        }
        // In the inner join, expressions in the on are equal at the resulting table.
        if *join_type == JoinType::Inner {
            on.iter().for_each(|(lhs, rhs)| {
                let new_lhs = Arc::new(lhs.clone()) as _;
                let new_rhs =
                    Arc::new(Column::new(rhs.name(), rhs.index() + left_columns_len))
                        as _;
                res.add_equal_conditions((&new_lhs, &new_rhs));
            });
        }
        Ok(res)
    }
}

/// Stores the mapping between source expression and target expression during projection
/// Indices in the vector corresponds to index after projection.
pub type ProjectionMapping = Vec<(Arc<dyn PhysicalExpr>, Arc<dyn PhysicalExpr>)>;

/// `LexOrdering` stores the lexicographical ordering for a schema.
/// OrderingEquivalentClass keeps track of different alternative orderings than can
/// describe the schema.
/// For instance, for the table below
/// |a|b|c|d|
/// |1|4|3|1|
/// |2|3|3|2|
/// |3|1|2|2|
/// |3|2|1|3|
/// both `vec![a ASC, b ASC]` and `vec![c DESC, d ASC]` describe the ordering of the table.
/// For this case, we say that `vec![a ASC, b ASC]`, and `vec![c DESC, d ASC]` are ordering equivalent.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub struct OrderingEquivalentGroup {
    inner: Vec<LexOrdering>,
}

impl OrderingEquivalentGroup {
    /// Creates new empty ordering equivalent group
    fn empty() -> Self {
        OrderingEquivalentGroup { inner: vec![] }
    }

    /// Creates new ordering equivalent from given vector
    pub fn new(entries: Vec<LexOrdering>) -> Self {
        let mut res = OrderingEquivalentGroup { inner: entries };
        // Make sure ordering equivalences doesn't contain something redundant
        res.remove_redundant_entries();
        res
    }

    /// Check whether ordering is in the state.
    pub fn contains(&self, other: &LexOrdering) -> bool {
        self.inner.contains(other)
    }

    /// Pushes new ordering to the state.
    fn push(&mut self, other: LexOrdering) {
        if !self.contains(&other) {
            self.inner.push(other);
        }
        // Make sure that after new entry there is no redundant
        // entry in the state.
        self.remove_redundant_entries();
    }

    /// Adds new ordering into the ordering equivalent group.
    pub fn add_new_orderings(&mut self, orderings: &[LexOrdering]) {
        for ordering in orderings.iter() {
            self.push(ordering.clone());
        }
        self.remove_redundant_entries();
    }

    /// Removes redundant orderings from the state.
    /// For instance, If we already know that
    /// ordering: [a ASC, b ASC, c DESC] is valid for the schema.
    /// There is no need to keep ordering [a ASC, b ASC] in the state.
    fn remove_redundant_entries(&mut self) {
        // Make sure there is no redundant entry
        let mut res: Vec<LexOrdering> = vec![];
        for ordering in self.iter() {
            let mut is_inside = false;
            for item in &mut res {
                if let Some(finer) = Self::get_finer_strict(item, ordering) {
                    *item = finer;
                    is_inside = true;
                }
            }
            if !is_inside {
                res.push(ordering.clone());
            }
        }
        self.inner = res;
    }

    /// Check whether ordering equivalent group is empty
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn iter(&self) -> impl Iterator<Item = &LexOrdering> {
        self.inner.iter()
    }

    fn into_iter(self) -> impl Iterator<Item = LexOrdering> {
        self.inner.into_iter()
    }

    /// Get length of the entries in the ordering equivalent group
    fn len(&self) -> usize {
        self.inner.len()
    }

    /// Extend ordering equivalent group with other group
    pub fn extend(&mut self, other: OrderingEquivalentGroup) {
        for ordering in other.iter() {
            if !self.contains(ordering) {
                self.inner.push(ordering.clone())
            }
        }
        self.remove_redundant_entries();
    }

    /// Get first ordering entry in the ordering equivalences
    /// This is one of the many valid orderings (if available)
    pub fn output_ordering(&self) -> Option<Vec<PhysicalSortExpr>> {
        self.inner.first().cloned()
    }

    // Append other as postfix to existing ordering equivalences
    pub fn join_postfix(
        &self,
        other: &OrderingEquivalentGroup,
    ) -> OrderingEquivalentGroup {
        if other.is_empty() {
            return OrderingEquivalentGroup::new(self.inner.clone());
        }
        let mut res = vec![];
        for ordering in self.iter() {
            for postfix in other.iter() {
                let mut new_ordering = ordering.clone();
                new_ordering.extend(postfix.clone());
                res.push(new_ordering)
            }
        }
        OrderingEquivalentGroup::new(res)
    }

    /// Adds `offset` value to the index of each expression inside `OrderingEquivalentGroup`.
    pub fn add_offset(&self, offset: usize) -> Result<OrderingEquivalentGroup> {
        let res = self
            .inner
            .iter()
            .map(|ordering| add_offset_to_lex_ordering(ordering, offset))
            .collect::<Result<Vec<_>>>()?;
        Ok(OrderingEquivalentGroup::new(res))
    }

    /// Return finer ordering between lhs and rhs.
    fn get_finer_strict(
        lhs: &[PhysicalSortExpr],
        rhs: &[PhysicalSortExpr],
    ) -> Option<Vec<PhysicalSortExpr>> {
        if izip!(lhs.iter(), rhs.iter()).all(|(lhs, rhs)| lhs.eq(rhs)) {
            if lhs.len() > rhs.len() {
                return Some(lhs.to_vec());
            } else {
                return Some(rhs.to_vec());
            }
        }
        None
    }

    /// Get leading ordering of the expression if it is ordered.
    /// `None` means expression is not ordered.
    fn get_ordering(&self, expr: &Arc<dyn PhysicalExpr>) -> Option<SortOptions> {
        for ordering in self.iter() {
            let leading_ordering = &ordering[0];
            if expr.eq(&leading_ordering.expr) {
                return Some(leading_ordering.options);
            }
        }
        None
    }
}

/// `OrderingEquivalenceProperties` keeps track of columns that describe the
/// global ordering of the schema. These columns are not necessarily same; e.g.
/// ```text
/// ┌-------┐
/// | a | b |
/// |---|---|
/// | 1 | 9 |
/// | 2 | 8 |
/// | 3 | 7 |
/// | 5 | 5 |
/// └---┴---┘
/// ```
/// where both `a ASC` and `b DESC` can describe the table ordering. With
/// `OrderingEquivalenceProperties`, we can keep track of these equivalences
/// and treat `a ASC` and `b DESC` as the same ordering requirement.
#[derive(Debug, Clone)]
pub struct OrderingEquivalenceProperties {
    /// Keeps track of expressions that have equivalent value.
    eq_groups: EquivalentGroups,
    /// Keeps track of valid ordering that satisfied table.
    oeq_group: OrderingEquivalentGroup,
    /// Keeps track of expressions that have constant value.
    /// TODO: We do not need to track constants separately, they can be tracked
    ///  inside `eq_groups` as `Literal` expressions.
    constants: Vec<Arc<dyn PhysicalExpr>>,
    schema: SchemaRef,
}

impl OrderingEquivalenceProperties {
    /// Create an empty `OrderingEquivalenceProperties`
    pub fn new(schema: SchemaRef) -> Self {
        Self {
            eq_groups: EquivalentGroups::empty(),
            oeq_group: OrderingEquivalentGroup::empty(),
            constants: vec![],
            schema,
        }
    }

    /// Extends `OrderingEquivalenceProperties` by adding ordering inside the `other`
    /// to the `self.oeq_class`.
    pub fn extend(&mut self, other: OrderingEquivalentGroup) {
        for ordering in other.into_iter() {
            if !self.oeq_group.contains(&ordering) {
                self.oeq_group.push(ordering);
            }
        }
        self.normalize_state();
    }

    /// Return a reference to the ordering equivalent group
    pub fn oeq_group(&self) -> &OrderingEquivalentGroup {
        &self.oeq_group
    }

    /// Return a reference to the equivalent groups
    pub fn eq_groups(&self) -> &EquivalentGroups {
        &self.eq_groups
    }

    /// Adds new ordering into the ordering equivalent group.
    pub fn add_new_orderings(&mut self, orderings: &[LexOrdering]) {
        self.oeq_group.add_new_orderings(orderings);
        self.normalize_state();
    }

    /// Add new equivalent group to state.
    pub fn add_equivalent_groups(&mut self, other_eq_group: EquivalentGroups) {
        self.eq_groups.extend(other_eq_group);
        self.normalize_state();
    }

    /// Adds new equality group into the equivalent groups.
    /// If equalities are new, otherwise extends corresponding group.
    pub fn add_equal_conditions(
        &mut self,
        new_conditions: (&Arc<dyn PhysicalExpr>, &Arc<dyn PhysicalExpr>),
    ) {
        self.eq_groups.add_equal_conditions(new_conditions);
        self.normalize_state();
    }

    /// Normalizes state according to equivalent classes
    /// This util makes sure that all of the entries that have have equivalent groups among the ordering equivalent group
    /// uses representative expression of corresponding equivalent group (first entry in the group).
    fn normalize_state(&mut self) {
        let normalized_ordering = self
            .oeq_group
            .inner
            .iter()
            .map(|ordering| {
                // Use a representative version of the each equivalent group inside ordering expressions.
                let ordering = self.eq_groups.normalize_sort_exprs(ordering);
                // Prune with constants
                let req = prune_sort_reqs_with_constants(
                    &PhysicalSortRequirement::from_sort_exprs(&ordering),
                    &self.constants,
                );
                PhysicalSortRequirement::to_sort_exprs(req)
            })
            .collect::<Vec<Vec<_>>>();
        // Create new oeq group normalized according to equivalent groups.
        self.oeq_group = OrderingEquivalentGroup::new(normalized_ordering);
    }

    /// Add physical expression that have constant value to the `self.constants`
    pub fn with_constants(mut self, constants: Vec<Arc<dyn PhysicalExpr>>) -> Self {
        constants.into_iter().for_each(|constant| {
            if !physical_exprs_contains(&self.constants, &constant) {
                self.constants.push(constant);
            }
        });
        self.normalize_state();
        self
    }

    /// Get schema.
    pub fn schema(&self) -> SchemaRef {
        self.schema.clone()
    }

    /// Transform `sort_exprs` vector, to standardized version using `eq_properties` and `ordering_eq_properties`
    /// Assume `eq_properties` states that `Column a` and `Column b` are aliases.
    /// Also assume `ordering_eq_properties` states that ordering `vec![d ASC]` and `vec![a ASC, c ASC]` are
    /// ordering equivalent (in the sense that both describe the ordering of the table).
    /// If the `sort_exprs` input to this function were `vec![b ASC, c ASC]`,
    /// This function converts `sort_exprs` `vec![b ASC, c ASC]` to first `vec![a ASC, c ASC]` after considering `eq_properties`
    /// Then converts `vec![a ASC, c ASC]` to `vec![d ASC]` after considering `ordering_eq_properties`.
    /// Standardized version `vec![d ASC]` is used in subsequent operations.
    pub fn normalize_sort_exprs(
        &self,
        sort_exprs: &[PhysicalSortExpr],
    ) -> Vec<PhysicalSortExpr> {
        // Convert `PhysicalSortExpr`s to `PhysicalSortRequirement`s
        let sort_requirements =
            PhysicalSortRequirement::from_sort_exprs(sort_exprs.iter());
        let normalized_exprs = self.normalize_sort_requirements(&sort_requirements);
        // Convert back `PhysicalSortRequirement`s to `PhysicalSortExpr`s
        PhysicalSortRequirement::to_sort_exprs(normalized_exprs)
    }

    /// This function normalizes `sort_reqs` by
    /// - removing expressions that have constant value from requirement
    /// - replacing sections that are in the `self.oeq_class.others` with `self.oeq_class.head`
    /// - removing sections that satisfies global ordering that are in the post fix of requirement
    ///
    /// Transform `sort_reqs` vector, to standardized version using `eq_properties` and `ordering_eq_properties`
    /// Assume `eq_properties` states that `Column a` and `Column b` are aliases.
    /// Also assume `ordering_eq_properties` states that ordering `vec![d ASC]` and `vec![a ASC, c ASC]` are
    /// ordering equivalent (in the sense that both describe the ordering of the table).
    /// If the `sort_reqs` input to this function were `vec![b Some(ASC), c None]`,
    /// This function converts `sort_exprs` `vec![b Some(ASC), c None]` to first `vec![a Some(ASC), c None]` after considering `eq_properties`
    /// Then converts `vec![a Some(ASC), c None]` to `vec![d Some(ASC)]` after considering `ordering_eq_properties`.
    /// Standardized version `vec![d Some(ASC)]` is used in subsequent operations.
    pub fn normalize_sort_requirements(
        &self,
        sort_reqs: &[PhysicalSortRequirement],
    ) -> Vec<PhysicalSortRequirement> {
        let normalized_sort_reqs = self.eq_groups.normalize_sort_requirements(sort_reqs);
        // Remove entries that are known to be constant from requirement expression.
        let normalized_sort_reqs =
            prune_sort_reqs_with_constants(&normalized_sort_reqs, &self.constants);
        let mut normalized_sort_reqs = collapse_lex_req(normalized_sort_reqs);
        if self.oeq_group.is_empty() {
            return normalized_sort_reqs;
        }
        let first_entry =
            PhysicalSortRequirement::from_sort_exprs(&self.oeq_group.inner[0]);
        let first_entry = self.eq_groups.normalize_sort_requirements(&first_entry);
        for item in self.oeq_group.iter() {
            let item = PhysicalSortRequirement::from_sort_exprs(item);
            let item = self.eq_groups.normalize_sort_requirements(&item);
            let ranges = get_compatible_ranges(&normalized_sort_reqs, &item);
            let mut offset: i64 = 0;
            for Range { start, end } in ranges {
                let mut head = first_entry.clone();
                let updated_start = (start as i64 + offset) as usize;
                let updated_end = (end as i64 + offset) as usize;
                let range = end - start;
                offset += head.len() as i64 - range as i64;
                let all_none = normalized_sort_reqs[updated_start..updated_end]
                    .iter()
                    .all(|req| req.options.is_none());
                if all_none {
                    for req in head.iter_mut() {
                        req.options = None;
                    }
                }
                normalized_sort_reqs.splice(updated_start..updated_end, head);
            }
        }
        normalized_sort_reqs = simplify_lex_req(normalized_sort_reqs, &self.oeq_group);

        collapse_lex_req(normalized_sort_reqs)
    }

    /// Checks whether `leading_ordering` is contained in any of the ordering
    /// equivalence classes.
    pub fn satisfies_leading_ordering(
        &self,
        leading_ordering: &PhysicalSortExpr,
    ) -> bool {
        self.oeq_group()
            .iter()
            .any(|ordering| ordering[0].eq(leading_ordering))
    }

    /// Projects `OrderingEquivalenceProperties` according to mapping given in `source_to_target_mapping`.
    pub fn project(
        &self,
        source_to_target_mapping: &ProjectionMapping,
        output_schema: SchemaRef,
    ) -> OrderingEquivalenceProperties {
        let mut projected_properties = OrderingEquivalenceProperties::new(output_schema);

        let projected_eq_groups = self.eq_groups.project(source_to_target_mapping);
        projected_properties.eq_groups = projected_eq_groups;

        let projected_orderings = self
            .oeq_group
            .iter()
            .filter_map(|order| {
                self.eq_groups
                    .project_ordering(source_to_target_mapping, order)
            })
            .collect::<Vec<_>>();

        // if empty, no need to track projected_orderings.
        if !projected_orderings.is_empty() {
            projected_properties.oeq_group =
                OrderingEquivalentGroup::new(projected_orderings);
        }

        for (source, target) in source_to_target_mapping {
            let initial_expr = ExprOrdering::new(source.clone());
            let transformed = initial_expr
                .transform_up(&|expr| update_ordering(expr, self))
                .unwrap();
            if let Some(SortProperties::Ordered(sort_options)) = transformed.state {
                let sort_expr = PhysicalSortExpr {
                    expr: target.clone(),
                    options: sort_options,
                };
                // Push new ordering to the state.
                projected_properties.oeq_group.push(vec![sort_expr]);
            }
        }
        // Remove redundant entries from ordering group if any.
        // projected_properties.oeq_group.remove_redundant_entries();
        projected_properties
    }

    /// Re-creates `OrderingEquivalenceProperties` given that
    /// schema is re-ordered by `sort_expr` in the argument.
    pub fn with_reorder(
        mut self,
        sort_expr: Vec<PhysicalSortExpr>,
    ) -> OrderingEquivalenceProperties {
        // TODO: In some cases, existing ordering equivalences may still be valid add this analysis.

        // Normalize sort_expr according to equivalences
        let sort_expr = self.eq_groups.normalize_sort_exprs(&sort_expr);

        // Remove redundant entries from the lex ordering.
        let sort_expr = collapse_lex_ordering(sort_expr);

        // Reset ordering equivalent group with the new ordering.
        // Constants, and equivalent groups are still valid after re-sort.
        // Hence only `oeq_group` is overwritten.
        self.oeq_group = OrderingEquivalentGroup::new(vec![sort_expr]);
        self
    }

    /// Check whether any permutation of the argument has a prefix with existing ordering.
    /// Return indices that describes ordering and their ordering information.
    fn set_satisfy_helper(
        &self,
        exprs: &[Arc<dyn PhysicalExpr>],
    ) -> Option<Vec<(usize, SortOptions)>> {
        let exprs_normalized = self.eq_groups.normalize_exprs(exprs);
        let mut best = vec![];

        for ordering in self.oeq_group.iter() {
            let ordering = self.eq_groups.normalize_sort_exprs(ordering);
            let ordering_exprs = ordering
                .iter()
                .map(|sort_expr| sort_expr.expr.clone())
                .collect::<Vec<_>>();
            let mut ordered_indices =
                get_indices_of_exprs_strict(&exprs_normalized, &ordering_exprs);
            ordered_indices.sort();
            // Find out how many expressions of the existing ordering define ordering
            // for expressions in the GROUP BY clause. For example, if the input is
            // ordered by a, b, c, d and we group by b, a, d; the result below would be.
            // 2, meaning 2 elements (a, b) among the GROUP BY columns define ordering.
            let first_n = longest_consecutive_prefix(ordered_indices);
            if first_n > best.len() {
                let ordered_exprs = ordering_exprs[0..first_n].to_vec();
                // Find indices for the GROUP BY expressions such that when we iterate with
                // these indices, we would match existing ordering. For the example above,
                // this would produce 1, 0; meaning 1st and 0th entries (a, b) among the
                // GROUP BY expressions b, a, d match input ordering.
                let indices =
                    get_indices_of_exprs_strict(&ordered_exprs, &exprs_normalized);
                best = indices
                    .iter()
                    .enumerate()
                    .map(|(order_idx, &match_idx)| {
                        (match_idx, ordering[order_idx].options)
                    })
                    .collect();
            }
        }

        if best.is_empty() {
            None
        } else {
            Some(best)
        }
    }

    /// Check whether any permutation of the argument has a prefix with existing ordering.
    /// Return indices that describes ordering and their ordering information.
    pub fn set_satisfy(&self, exprs: &[Arc<dyn PhysicalExpr>]) -> Option<Vec<usize>> {
        self.set_satisfy_helper(exprs).map(|indices_and_orders| {
            indices_and_orders
                .into_iter()
                .map(|(idx, _options)| idx)
                .collect()
        })
    }

    /// Check whether one of the permutation of the exprs satisfies existing ordering.
    /// If so, return indices and their orderings.
    /// None, indicates that there is no permutation that satisfies ordering.
    pub fn set_exactly_satisfy(
        &self,
        exprs: &[Arc<dyn PhysicalExpr>],
    ) -> Option<Vec<(usize, SortOptions)>> {
        if let Some(indices_and_orders) = self.set_satisfy_helper(exprs) {
            if indices_and_orders.len() == exprs.len() {
                return Some(indices_and_orders);
            }
        }
        None
    }

    /// Empties the `oeq_group` inside self, When existing orderings are invalidated.
    pub fn with_empty_ordering_equivalence(mut self) -> OrderingEquivalenceProperties {
        self.oeq_group = OrderingEquivalentGroup::empty();
        self
    }

    /// Checks whether given ordering requirements are satisfied by provided [PhysicalSortExpr]s.
    pub fn ordering_satisfy(&self, required: Option<&[PhysicalSortExpr]>) -> bool {
        match required {
            None => true,
            Some(required) => self.ordering_satisfy_concrete(required),
        }
    }

    /// Checks whether the required [`PhysicalSortExpr`]s are satisfied by the
    /// any of the existing orderings.
    pub fn ordering_satisfy_concrete(&self, required: &[PhysicalSortExpr]) -> bool {
        let required_normalized = self.normalize_sort_exprs(required);
        let provided_normalized = self.oeq_group().output_ordering().unwrap_or(vec![]);
        if required_normalized.len() > provided_normalized.len() {
            return false;
        }

        required_normalized
            .into_iter()
            .zip(provided_normalized)
            .all(|(req, given)| given == req)
    }

    /// Find the finer requirement among `req1` and `req2`
    /// If `None`, this means that `req1` and `req2` are not compatible
    /// e.g there is no requirement that satisfies both
    pub fn get_finer_ordering<'a>(
        &self,
        req1: &'a [PhysicalSortExpr],
        req2: &'a [PhysicalSortExpr],
    ) -> Option<&'a [PhysicalSortExpr]> {
        let lhs = self.normalize_sort_exprs(req1);
        let rhs = self.normalize_sort_exprs(req2);
        if izip!(lhs.iter(), rhs.iter()).all(|(lhs, rhs)| lhs.eq(rhs)) {
            if lhs.len() > rhs.len() {
                return Some(req1);
            } else {
                return Some(req2);
            }
        }
        // Neither `provided` nor `req` satisfies one another, they are incompatible.
        None
    }

    /// Find the finer requirement among `req1` and `req2`
    /// If `None`, this means that `req1` and `req2` are not compatible
    /// e.g there is no requirement that satisfies both
    pub fn get_finer_requirement<'a>(
        &self,
        req1: &'a [PhysicalSortRequirement],
        req2: &'a [PhysicalSortRequirement],
    ) -> Option<&'a [PhysicalSortRequirement]> {
        let lhs = self.normalize_sort_requirements(req1);
        let rhs = self.normalize_sort_requirements(req2);
        let mut left_finer = false;
        let mut right_finer = false;
        if izip!(lhs.iter(), rhs.iter()).all(|(lhs, rhs)| {
            match (lhs.options, rhs.options) {
                (Some(lhs_opt), Some(rhs_opt)) => {
                    lhs.expr.eq(&rhs.expr) && lhs_opt == rhs_opt
                }
                (Some(_), None) => {
                    left_finer = true;
                    lhs.expr.eq(&rhs.expr)
                }
                (None, Some(_)) => {
                    right_finer = true;
                    lhs.expr.eq(&rhs.expr)
                }
                (None, None) => lhs.expr.eq(&rhs.expr),
            }
        }) {
            if lhs.len() >= rhs.len() && !right_finer {
                return Some(req1);
            } else if rhs.len() >= lhs.len() && !left_finer {
                return Some(req2);
            }
        }
        // Neither `provided` nor `req` satisfies one another, they are incompatible.
        None
    }

    /// Checks whether the given [`PhysicalSortRequirement`]s are satisfied by the
    /// provided [`PhysicalSortExpr`]s.
    pub fn ordering_satisfy_requirement(
        &self,
        required: Option<&[PhysicalSortRequirement]>,
    ) -> bool {
        match required {
            None => true,
            Some(required) => self.ordering_satisfy_requirement_concrete(required),
        }
    }

    /// Checks whether the given [`PhysicalSortRequirement`]s are satisfied by the
    /// provided [`PhysicalSortExpr`]s.
    pub fn ordering_satisfy_requirement_concrete(
        &self,
        required: &[PhysicalSortRequirement],
    ) -> bool {
        let provided_normalized = self.oeq_group().output_ordering().unwrap_or(vec![]);
        let required_normalized = self.normalize_sort_requirements(required);
        if required_normalized.len() > provided_normalized.len() {
            return false;
        }
        required_normalized
            .into_iter()
            .zip(provided_normalized)
            .all(|(req, given)| given.satisfy_with_schema(&req, &self.schema))
    }

    /// Checks whether the given [`PhysicalSortRequirement`]s are equal or more
    /// specific than the provided [`PhysicalSortRequirement`]s.
    pub fn requirements_compatible(
        &self,
        provided: Option<&[PhysicalSortRequirement]>,
        required: Option<&[PhysicalSortRequirement]>,
    ) -> bool {
        match (provided, required) {
            (_, None) => true,
            (None, Some(_)) => false,
            (Some(provided), Some(required)) => {
                self.requirements_compatible_concrete(provided, required)
            }
        }
    }

    /// Checks whether the given [`PhysicalSortRequirement`]s are equal or more
    /// specific than the provided [`PhysicalSortRequirement`]s.
    fn requirements_compatible_concrete(
        &self,
        provided: &[PhysicalSortRequirement],
        required: &[PhysicalSortRequirement],
    ) -> bool {
        let required_normalized = self.normalize_sort_requirements(required);
        let provided_normalized = self.normalize_sort_requirements(provided);
        if required_normalized.len() > provided_normalized.len() {
            return false;
        }
        required_normalized
            .into_iter()
            .zip(provided_normalized)
            .all(|(req, given)| given.compatible(&req))
    }

    /// Compares physical ordering (output ordering of the `input` operator) with
    /// `partitionby_exprs` and `orderby_keys` to decide whether existing ordering
    /// is sufficient to run the current window operator.
    /// - A `None` return value indicates that we can not remove the sort in question
    ///   (input ordering is not sufficient to run current window executor).
    /// - A `Some((bool, PartitionSearchMode))` value indicates that the window operator
    ///   can run with existing input ordering, so we can remove `SortExec` before it.
    /// The `bool` field in the return value represents whether we should reverse window
    /// operator to remove `SortExec` before it. The `PartitionSearchMode` field represents
    /// the mode this window operator should work in to accomodate the existing ordering.
    pub fn get_window_mode(
        &self,
        partitionby_exprs: &[Arc<dyn PhysicalExpr>],
        orderby_keys: &[PhysicalSortExpr],
    ) -> Result<Option<(bool, PartitionSearchMode)>> {
        let partitionby_exprs = self.eq_groups.normalize_exprs(partitionby_exprs);
        let mut orderby_keys = self.eq_groups.normalize_sort_exprs(orderby_keys);
        // Keep the order by expressions that are not inside partition by expressions.
        orderby_keys.retain(|sort_expr| {
            !physical_exprs_contains(&partitionby_exprs, &sort_expr.expr)
        });
        let mut partition_search_mode = PartitionSearchMode::Linear;
        let mut partition_by_reqs: Vec<PhysicalSortRequirement> = vec![];
        if partitionby_exprs.is_empty() {
            partition_search_mode = PartitionSearchMode::Sorted;
        } else if let Some(indices) = self.set_satisfy(&partitionby_exprs) {
            let elem = indices
                .iter()
                .map(|&idx| PhysicalSortRequirement {
                    expr: partitionby_exprs[idx].clone(),
                    options: None,
                })
                .collect::<Vec<_>>();
            partition_by_reqs.extend(elem);
            if indices.len() == partitionby_exprs.len() {
                partition_search_mode = PartitionSearchMode::Sorted;
            } else if !indices.is_empty() {
                partition_search_mode = PartitionSearchMode::PartiallySorted(indices);
            }
        }

        let order_by_reqs = PhysicalSortRequirement::from_sort_exprs(&orderby_keys);
        let req = [partition_by_reqs.clone(), order_by_reqs].concat();
        let req = collapse_lex_req(req);
        if req.is_empty() {
            // When requirement is empty,
            // prefer None. Instead of Linear.
            return Ok(None);
        }
        // Treat partition by exprs as constant. During analysis of requirements are satisfied.
        let partition_by_oeq = self.clone().with_constants(partitionby_exprs.clone());
        if partition_by_oeq.ordering_satisfy_requirement_concrete(&req) {
            // Window can be run with existing ordering
            return Ok(Some((false, partition_search_mode)));
        }
        let reverse_order_by_reqs =
            PhysicalSortRequirement::from_sort_exprs(&reverse_order_bys(&orderby_keys));
        let req = [partition_by_reqs, reverse_order_by_reqs].concat();
        let req = collapse_lex_req(req);
        if partition_by_oeq.ordering_satisfy_requirement_concrete(&req) {
            // Window can be run with existing ordering, if the ordering requirements would be reversed
            return Ok(Some((true, partition_search_mode)));
        }
        Ok(None)
    }

    /// Calculate ordering equivalence properties for the given join operation.
    pub fn join(
        &self,
        join_type: &JoinType,
        right: &OrderingEquivalenceProperties,
        join_schema: SchemaRef,
        maintains_input_order: &[bool],
        probe_side: Option<JoinSide>,
        on: &[(Column, Column)],
    ) -> Result<OrderingEquivalenceProperties> {
        let left_columns_len = self.schema.fields.len();
        let mut new_properties = OrderingEquivalenceProperties::new(join_schema);

        let join_eq_groups =
            self.eq_groups()
                .join(join_type, right.eq_groups(), left_columns_len, on)?;
        new_properties.add_equivalent_groups(join_eq_groups);

        // All joins have 2 children
        assert_eq!(maintains_input_order.len(), 2);
        let left_maintains = maintains_input_order[0];
        let right_maintains = maintains_input_order[1];
        let left_oeq_class = self.oeq_group();
        let right_oeq_class = right.oeq_group();
        match (left_maintains, right_maintains) {
            (true, true) => {
                return Err(DataFusionError::Plan(
                    "Cannot maintain ordering of both sides".to_string(),
                ))
            }
            (true, false) => {
                // In this special case, right side ordering can be prefixed with left side ordering.
                if let (Some(JoinSide::Left), JoinType::Inner) = (probe_side, join_type) {
                    let updated_right_oeq = get_updated_right_ordering_equivalent_group(
                        join_type,
                        right_oeq_class,
                        left_columns_len,
                    )?;

                    // Right side ordering equivalence properties should be prepended with
                    // those of the left side while constructing output ordering equivalence
                    // properties since stream side is the left side.
                    //
                    // If the right table ordering equivalences contain `b ASC`, and the output
                    // ordering of the left table is `a ASC`, then the ordering equivalence `b ASC`
                    // for the right table should be converted to `a ASC, b ASC` before it is added
                    // to the ordering equivalences of the join.
                    let out_oeq_class = left_oeq_class.join_postfix(&updated_right_oeq);
                    new_properties.extend(out_oeq_class);
                } else {
                    new_properties.extend(left_oeq_class.clone());
                }
            }
            (false, true) => {
                let updated_right_oeq = get_updated_right_ordering_equivalent_group(
                    join_type,
                    right.oeq_group(),
                    left_columns_len,
                )?;
                // In this special case, left side ordering can be prefixed with right side ordering.
                if let (Some(JoinSide::Right), JoinType::Inner) = (probe_side, join_type)
                {
                    // Left side ordering equivalence properties should be prepended with
                    // those of the right side while constructing output ordering equivalence
                    // properties since stream side is the right side.
                    //
                    // If the right table ordering equivalences contain `b ASC`, and the output
                    // ordering of the left table is `a ASC`, then the ordering equivalence `b ASC`
                    // for the right table should be converted to `a ASC, b ASC` before it is added
                    // to the ordering equivalences of the join.
                    let out_oeq_class = updated_right_oeq.join_postfix(left_oeq_class);
                    new_properties.extend(out_oeq_class);
                } else {
                    new_properties.extend(updated_right_oeq);
                }
            }
            (false, false) => {}
        }
        Ok(new_properties)
    }
}

#[derive(Debug, Clone, PartialEq)]
/// Specifies partition column properties in terms of input ordering
pub enum PartitionSearchMode {
    /// None of the columns among the partition columns is ordered.
    Linear,
    /// Some columns of the partition columns are ordered but not all
    PartiallySorted(Vec<usize>),
    /// All Partition columns are ordered (Also empty case)
    Sorted,
}

/// This is a builder object facilitating incremental construction
/// for ordering equivalences.
pub struct OrderingEquivalenceBuilder {
    // eq_properties: EquivalenceProperties,
    ordering_eq_properties: OrderingEquivalenceProperties,
    existing_ordering: Vec<PhysicalSortExpr>,
    schema: SchemaRef,
}

impl OrderingEquivalenceBuilder {
    pub fn new(schema: SchemaRef) -> Self {
        // let eq_properties = EquivalenceProperties::new(schema.clone());
        let ordering_eq_properties = OrderingEquivalenceProperties::new(schema.clone());
        Self {
            // eq_properties,
            ordering_eq_properties,
            existing_ordering: vec![],
            schema,
        }
    }

    pub fn extend(
        mut self,
        new_ordering_eq_properties: OrderingEquivalenceProperties,
    ) -> Self {
        self.ordering_eq_properties
            .eq_groups
            .extend(new_ordering_eq_properties.eq_groups);
        self.ordering_eq_properties
            .extend(new_ordering_eq_properties.oeq_group);
        self
    }

    pub fn with_existing_ordering(
        mut self,
        existing_ordering: Option<Vec<PhysicalSortExpr>>,
    ) -> Self {
        if let Some(existing_ordering) = existing_ordering {
            self.existing_ordering = existing_ordering;
        }
        self
    }

    pub fn add_equal_conditions(
        &mut self,
        new_equivalent_ordering: Vec<PhysicalSortExpr>,
    ) {
        let mut normalized_out_ordering = vec![];
        for item in &self.existing_ordering {
            // To account for ordering equivalences, first normalize the expression:
            // let normalized = self.eq_properties.normalize_expr(item.expr.clone());
            normalized_out_ordering.push(PhysicalSortExpr {
                expr: item.expr.clone(),
                options: item.options,
            });
        }
        // If there is an existing ordering, add new ordering as an equivalence:
        if !normalized_out_ordering.is_empty() {
            self.ordering_eq_properties
                .add_new_orderings(&[normalized_out_ordering, new_equivalent_ordering]);
        }
    }

    /// Return a reference to the schema with which this builder was constructed with
    pub fn schema(&self) -> &SchemaRef {
        &self.schema
    }

    /// Return a reference to the existing ordering
    pub fn existing_ordering(&self) -> &LexOrdering {
        &self.existing_ordering
    }

    pub fn build(self) -> OrderingEquivalenceProperties {
        self.ordering_eq_properties
    }
}

/// Retrieves the ordering equivalence properties for a given schema and output ordering.
pub fn ordering_equivalence_properties_helper(
    schema: SchemaRef,
    eq_orderings: &[LexOrdering],
) -> OrderingEquivalenceProperties {
    let mut oep = OrderingEquivalenceProperties::new(schema);
    if eq_orderings.is_empty() {
        // Return an empty OrderingEquivalenceProperties:
        oep
    } else {
        oep.extend(OrderingEquivalentGroup::new(eq_orderings.to_vec()));
        oep
    }
}

/// This function constructs a duplicate-free `LexOrderingReq` by filtering out duplicate
/// entries that have same physical expression inside the given vector `input`.
/// `vec![a Some(Asc), a Some(Desc)]` is collapsed to the `vec![a Some(Asc)]`. Since
/// when same expression is already seen before, following expressions are redundant.
pub fn collapse_lex_req(input: LexOrderingReq) -> LexOrderingReq {
    let mut output = vec![];
    for item in input {
        if output
            .iter()
            .all(|elem: &PhysicalSortRequirement| !elem.expr.eq(&item.expr))
        {
            output.push(item);
        }
    }
    output
}

/// This function constructs a duplicate-free `LexOrdering` by filtering out duplicate
/// entries that have same physical expression inside the given vector `input`.
/// `vec![a ASC, a DESC]` is collapsed to the `vec![a ASC]`. Since
/// when same expression is already seen before, following expressions are redundant.
pub fn collapse_lex_ordering(input: LexOrdering) -> LexOrdering {
    let mut output = vec![];
    for item in input {
        if output
            .iter()
            .all(|elem: &PhysicalSortExpr| !elem.expr.eq(&item.expr))
        {
            output.push(item);
        }
    }
    output
}

/// This function simplifies lexicographical ordering requirement
/// inside `input` by removing postfix lexicographical requirements
/// that satisfy global ordering (occurs inside the ordering equivalent class)
fn simplify_lex_req(
    input: LexOrderingReq,
    oeq_class: &OrderingEquivalentGroup,
) -> LexOrderingReq {
    let mut section = &input[..];
    loop {
        let n_prune = prune_last_n_that_is_in_oeq(section, oeq_class);
        // Cannot prune entries from the end of requirement
        if n_prune == 0 {
            break;
        }
        section = &section[0..section.len() - n_prune];
    }
    if section.is_empty() {
        // By convention use first entry
        PhysicalSortRequirement::from_sort_exprs(&oeq_class.inner[0])
    } else {
        section.to_vec()
    }
}

/// Determines how many entries from the end can be deleted.
/// Last n entry satisfies global ordering, hence having them
/// as postfix in the lexicographical requirement is unnecessary.
/// Assume requirement is [a ASC, b ASC, c ASC], also assume that
/// existing ordering is [c ASC, d ASC]. In this case, since [c ASC]
/// is satisfied by the existing ordering (e.g corresponding section is global ordering),
/// [c ASC] can be pruned from the requirement: [a ASC, b ASC, c ASC]. In this case,
/// this function will return 1, to indicate last element can be removed from the requirement
fn prune_last_n_that_is_in_oeq(
    input: &[PhysicalSortRequirement],
    oeq_class: &OrderingEquivalentGroup,
) -> usize {
    let input_len = input.len();
    for ordering in oeq_class.iter() {
        let mut search_range = std::cmp::min(ordering.len(), input_len);
        while search_range > 0 {
            let req_section = &input[input_len - search_range..];
            // let given_section = &ordering[0..search_range];
            if req_satisfied(ordering, req_section) {
                return search_range;
            } else {
                search_range -= 1;
            }
        }
    }
    0
}

/// Checks whether given section satisfies req.
fn req_satisfied(given: LexOrderingRef, req: &[PhysicalSortRequirement]) -> bool {
    for (given, req) in izip!(given.iter(), req.iter()) {
        let PhysicalSortRequirement { expr, options } = req;
        if let Some(options) = options {
            if options != &given.options || !expr.eq(&given.expr) {
                return false;
            }
        } else if !expr.eq(&given.expr) {
            return false;
        }
    }
    true
}

/// This function searches for the slice `section` inside the slice `given`.
/// It returns each range where `section` is compatible with the corresponding
/// slice in `given`.
fn get_compatible_ranges(
    given: &[PhysicalSortRequirement],
    section: &[PhysicalSortRequirement],
) -> Vec<Range<usize>> {
    let n_section = section.len();
    let n_end = if given.len() >= n_section {
        given.len() - n_section + 1
    } else {
        0
    };
    (0..n_end)
        .filter_map(|idx| {
            let end = idx + n_section;
            given[idx..end]
                .iter()
                .zip(section)
                .all(|(req, given)| given.compatible(req))
                .then_some(Range { start: idx, end })
        })
        .collect()
}

/// Remove ordering requirements that have constant value
fn prune_sort_reqs_with_constants(
    ordering: &[PhysicalSortRequirement],
    constants: &[Arc<dyn PhysicalExpr>],
) -> Vec<PhysicalSortRequirement> {
    ordering
        .iter()
        .filter(|&order| !physical_exprs_contains(constants, &order.expr))
        .cloned()
        .collect()
}

/// Adds the `offset` value to `Column` indices inside `expr`. This function is
/// generally used during the update of the right table schema in join operations.
pub(crate) fn add_offset_to_exprs(
    exprs: Vec<Arc<dyn PhysicalExpr>>,
    offset: usize,
) -> Result<Vec<Arc<dyn PhysicalExpr>>> {
    exprs
        .into_iter()
        .map(|item| add_offset_to_expr(item, offset))
        .collect::<Result<Vec<_>>>()
}

/// Adds the `offset` value to `Column` indices inside `expr`. This function is
/// generally used during the update of the right table schema in join operations.
pub(crate) fn add_offset_to_expr(
    expr: Arc<dyn PhysicalExpr>,
    offset: usize,
) -> Result<Arc<dyn PhysicalExpr>> {
    expr.transform_down(&|e| match e.as_any().downcast_ref::<Column>() {
        Some(col) => Ok(Transformed::Yes(Arc::new(Column::new(
            col.name(),
            offset + col.index(),
        )))),
        None => Ok(Transformed::No(e)),
    })
}

/// Adds the `offset` value to `Column` indices inside `sort_expr.expr`.
pub(crate) fn add_offset_to_sort_expr(
    sort_expr: &PhysicalSortExpr,
    offset: usize,
) -> Result<PhysicalSortExpr> {
    Ok(PhysicalSortExpr {
        expr: add_offset_to_expr(sort_expr.expr.clone(), offset)?,
        options: sort_expr.options,
    })
}

/// Adds the `offset` value to `Column` indices for each `sort_expr.expr`
/// inside `sort_exprs`.
pub fn add_offset_to_lex_ordering(
    sort_exprs: LexOrderingRef,
    offset: usize,
) -> Result<LexOrdering> {
    sort_exprs
        .iter()
        .map(|sort_expr| add_offset_to_sort_expr(sort_expr, offset))
        .collect()
}

/// Calculates the [`SortProperties`] of a given [`ExprOrdering`] node.
/// The node is either a leaf node, or an intermediate node:
/// - If it is a leaf node, the children states are `None`. We directly find
/// the order of the node by looking at the given sort expression and equivalence
/// properties if it is a `Column` leaf, or we mark it as unordered. In the case
/// of a `Literal` leaf, we mark it as singleton so that it can cooperate with
/// some ordered columns at the upper steps.
/// - If it is an intermediate node, the children states matter. Each `PhysicalExpr`
/// and operator has its own rules about how to propagate the children orderings.
/// However, before the children order propagation, it is checked that whether
/// the intermediate node can be directly matched with the sort expression. If there
/// is a match, the sort expression emerges at that node immediately, discarding
/// the order coming from the children.
pub fn update_ordering(
    mut node: ExprOrdering,
    ordering_equal_properties: &OrderingEquivalenceProperties,
) -> Result<Transformed<ExprOrdering>> {
    let eq_groups = &ordering_equal_properties.eq_groups;
    let oeq_group = &ordering_equal_properties.oeq_group;
    if let Some(children_sort_options) = &node.children_states {
        // We have an intermediate (non-leaf) node, account for its children:
        node.state = Some(node.expr.get_ordering(children_sort_options));
        Ok(Transformed::Yes(node))
    } else if node.expr.as_any().is::<Column>() {
        // We have a Column, which is one of the two possible leaf node types:
        let normalized_expr = eq_groups.normalize_expr(node.expr.clone());
        if let Some(options) = oeq_group.get_ordering(&normalized_expr) {
            node.state = Some(SortProperties::Ordered(options));
            Ok(Transformed::Yes(node))
        } else {
            node.state = None;
            Ok(Transformed::No(node))
        }
    } else {
        // We have a Literal, which is the other possible leaf node type:
        node.state = Some(node.expr.get_ordering(&[]));
        Ok(Transformed::Yes(node))
    }
}

/// Update right table ordering equivalences so that:
/// - They point to valid indices at the output of the join schema, and
/// - They are normalized with respect to equivalence columns.
///
/// To do so, we increment column indices by the size of the left table when
/// join schema consists of a combination of left and right schema (Inner,
/// Left, Full, Right joins). Then, we normalize the sort expressions of
/// ordering equivalences one by one. We make sure that each expression in the
/// ordering equivalence is either:
/// - The head of the one of the equivalent classes, or
/// - Doesn't have an equivalent column.
///
/// This way; once we normalize an expression according to equivalence properties,
/// it can thereafter safely be used for ordering equivalence normalization.
fn get_updated_right_ordering_equivalent_group(
    join_type: &JoinType,
    right_oeq_group: &OrderingEquivalentGroup,
    left_columns_len: usize,
) -> Result<OrderingEquivalentGroup> {
    match join_type {
        // In these modes, indices of the right schema should be offset by
        // the left table size.
        JoinType::Inner | JoinType::Left | JoinType::Full | JoinType::Right => {
            return right_oeq_group.add_offset(left_columns_len)
        }
        _ => {}
    };
    Ok(right_oeq_group.clone())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::expressions::{col, lit, Column};
    use arrow::datatypes::{DataType, Field, Schema};
    use datafusion_common::Result;

    use crate::physical_expr::physical_exprs_equal;
    use arrow_schema::{Fields, SortOptions};
    use std::sync::Arc;

    // Generate a schema which consists of 5 columns (a, b, c, d, e)
    fn create_test_schema() -> Result<SchemaRef> {
        let a = Field::new("a", DataType::Int32, true);
        let b = Field::new("b", DataType::Int32, true);
        let c = Field::new("c", DataType::Int32, true);
        let d = Field::new("d", DataType::Int32, true);
        let e = Field::new("e", DataType::Int32, true);
        let f = Field::new("f", DataType::Int32, true);
        let schema = Arc::new(Schema::new(vec![a, b, c, d, e, f]));

        Ok(schema)
    }

    /// Construct a schema with following properties
    /// Schema satisfied following orderings:
    /// [a ASC], [d ASC, b ASC], [e DESC, f ASC, g ASC]
    /// and
    /// Column [a=c] (e.g they are aliases).
    fn create_test_params() -> Result<(SchemaRef, OrderingEquivalenceProperties)> {
        let col_a = &Column::new("a", 0);
        let col_b = &Column::new("b", 1);
        let col_c = &Column::new("c", 2);
        let col_d = &Column::new("d", 3);
        let col_e = &Column::new("e", 4);
        let col_f = &Column::new("f", 5);
        let col_g = &Column::new("g", 6);
        let option1 = SortOptions {
            descending: false,
            nulls_first: false,
        };
        let option2 = SortOptions {
            descending: true,
            nulls_first: true,
        };
        let test_schema = create_test_schema()?;
        let col_a_expr = Arc::new(col_a.clone()) as _;
        let col_c_expr = Arc::new(col_c.clone()) as _;
        let mut ordering_eq_properties =
            OrderingEquivalenceProperties::new(test_schema.clone());
        ordering_eq_properties.add_equal_conditions((&col_a_expr, &col_c_expr));
        ordering_eq_properties.add_new_orderings(&[
            vec![PhysicalSortExpr {
                expr: Arc::new(col_a.clone()),
                options: option1,
            }],
            vec![
                PhysicalSortExpr {
                    expr: Arc::new(col_d.clone()),
                    options: option1,
                },
                PhysicalSortExpr {
                    expr: Arc::new(col_b.clone()),
                    options: option1,
                },
            ],
            vec![
                PhysicalSortExpr {
                    expr: Arc::new(col_e.clone()),
                    options: option2,
                },
                PhysicalSortExpr {
                    expr: Arc::new(col_f.clone()),
                    options: option1,
                },
                PhysicalSortExpr {
                    expr: Arc::new(col_g.clone()),
                    options: option1,
                },
            ],
        ]);
        Ok((test_schema, ordering_eq_properties))
    }

    fn convert_to_requirement(
        in_data: &[(&Column, Option<SortOptions>)],
    ) -> Vec<PhysicalSortRequirement> {
        in_data
            .iter()
            .map(|(col, options)| {
                PhysicalSortRequirement::new(Arc::new((*col).clone()) as _, *options)
            })
            .collect::<Vec<_>>()
    }

    #[test]
    fn add_equal_conditions_test() -> Result<()> {
        let schema = Arc::new(Schema::new(vec![
            Field::new("a", DataType::Int64, true),
            Field::new("b", DataType::Int64, true),
            Field::new("c", DataType::Int64, true),
            Field::new("x", DataType::Int64, true),
            Field::new("y", DataType::Int64, true),
        ]));

        let mut eq_properties = OrderingEquivalenceProperties::new(schema);
        let col_a_expr = Arc::new(Column::new("a", 0)) as Arc<dyn PhysicalExpr>;
        let col_b_expr = Arc::new(Column::new("b", 1)) as Arc<dyn PhysicalExpr>;
        let col_c_expr = Arc::new(Column::new("c", 2)) as Arc<dyn PhysicalExpr>;
        let col_x_expr = Arc::new(Column::new("x", 3)) as Arc<dyn PhysicalExpr>;
        let col_y_expr = Arc::new(Column::new("y", 4)) as Arc<dyn PhysicalExpr>;

        let new_condition = (&col_a_expr, &col_b_expr);
        eq_properties.add_equal_conditions(new_condition);
        assert_eq!(eq_properties.eq_groups().len(), 1);

        let new_condition = (&col_b_expr, &col_a_expr);
        eq_properties.add_equal_conditions(new_condition);
        assert_eq!(eq_properties.eq_groups().len(), 1);
        let eq_class = &eq_properties.eq_groups().inner[0];
        assert_eq!(eq_class.len(), 2);
        assert!(physical_exprs_contains(eq_class, &col_a_expr));
        assert!(physical_exprs_contains(eq_class, &col_b_expr));

        let new_condition = (&col_b_expr, &col_c_expr);
        eq_properties.add_equal_conditions(new_condition);
        assert_eq!(eq_properties.eq_groups().len(), 1);
        let eq_class = &eq_properties.eq_groups().inner[0];
        assert_eq!(eq_class.len(), 3);
        assert!(physical_exprs_contains(eq_class, &col_a_expr));
        assert!(physical_exprs_contains(eq_class, &col_b_expr));
        assert!(physical_exprs_contains(eq_class, &col_c_expr));

        // This is a new set of equality. Hence equivalent class count should be 2.
        let new_condition = (&col_x_expr, &col_y_expr);
        eq_properties.add_equal_conditions(new_condition);
        assert_eq!(eq_properties.eq_groups().len(), 2);

        // This equality bridges distinct equality sets.
        // Hence equivalent class count should decrease from 2 to 1.
        let new_condition = (&col_x_expr, &col_a_expr);
        eq_properties.add_equal_conditions(new_condition);
        assert_eq!(eq_properties.eq_groups().len(), 1);
        let eq_class = &eq_properties.eq_groups().inner[0];
        assert_eq!(eq_class.len(), 5);
        assert!(physical_exprs_contains(eq_class, &col_a_expr));
        assert!(physical_exprs_contains(eq_class, &col_b_expr));
        assert!(physical_exprs_contains(eq_class, &col_c_expr));
        assert!(physical_exprs_contains(eq_class, &col_x_expr));
        assert!(physical_exprs_contains(eq_class, &col_y_expr));

        Ok(())
    }

    #[test]
    fn project_equivalence_properties_test() -> Result<()> {
        let input_schema = Arc::new(Schema::new(vec![
            Field::new("a", DataType::Int64, true),
            Field::new("b", DataType::Int64, true),
            Field::new("c", DataType::Int64, true),
        ]));

        let mut input_properties = OrderingEquivalenceProperties::new(input_schema);
        let col_a_expr = Arc::new(Column::new("a", 0)) as Arc<dyn PhysicalExpr>;
        let col_b_expr = Arc::new(Column::new("b", 1)) as Arc<dyn PhysicalExpr>;
        let col_c_expr = Arc::new(Column::new("c", 2)) as Arc<dyn PhysicalExpr>;

        let new_condition = (&col_a_expr, &col_b_expr);
        input_properties.add_equal_conditions(new_condition);
        let new_condition = (&col_b_expr, &col_c_expr);
        input_properties.add_equal_conditions(new_condition);

        let out_schema = Arc::new(Schema::new(vec![
            Field::new("a1", DataType::Int64, true),
            Field::new("a2", DataType::Int64, true),
            Field::new("a3", DataType::Int64, true),
            Field::new("a4", DataType::Int64, true),
        ]));

        let col_a1_expr = Arc::new(Column::new("a1", 0)) as Arc<dyn PhysicalExpr>;
        let col_a2_expr = Arc::new(Column::new("a2", 1)) as Arc<dyn PhysicalExpr>;
        let col_a3_expr = Arc::new(Column::new("a3", 2)) as Arc<dyn PhysicalExpr>;
        let col_a4_expr = Arc::new(Column::new("a4", 2)) as Arc<dyn PhysicalExpr>;
        let source_to_target_mapping = vec![
            (col_a_expr.clone(), col_a1_expr.clone()),
            (col_a_expr.clone(), col_a2_expr.clone()),
            (col_a_expr.clone(), col_a3_expr.clone()),
            (col_a_expr.clone(), col_a4_expr.clone()),
        ];
        // let mut out_properties = OrderingEquivalenceProperties::new(out_schema);
        let out_properties =
            input_properties.project(&source_to_target_mapping, out_schema);

        assert_eq!(out_properties.eq_groups().len(), 1);
        let eq_class = &out_properties.eq_groups().inner[0];
        assert_eq!(eq_class.len(), 4);
        assert!(physical_exprs_contains(eq_class, &col_a1_expr));
        assert!(physical_exprs_contains(eq_class, &col_a2_expr));
        assert!(physical_exprs_contains(eq_class, &col_a3_expr));
        assert!(physical_exprs_contains(eq_class, &col_a4_expr));

        Ok(())
    }

    #[test]
    fn test_get_compatible_ranges() -> Result<()> {
        let col_a = &Column::new("a", 0);
        let col_b = &Column::new("b", 1);
        let option1 = SortOptions {
            descending: false,
            nulls_first: false,
        };
        let test_data = vec![
            (
                vec![(col_a, Some(option1)), (col_b, Some(option1))],
                vec![(col_a, Some(option1))],
                vec![(0, 1)],
            ),
            (
                vec![(col_a, None), (col_b, Some(option1))],
                vec![(col_a, Some(option1))],
                vec![(0, 1)],
            ),
            (
                vec![
                    (col_a, None),
                    (col_b, Some(option1)),
                    (col_a, Some(option1)),
                ],
                vec![(col_a, Some(option1))],
                vec![(0, 1), (2, 3)],
            ),
        ];
        for (searched, to_search, expected) in test_data {
            let searched = convert_to_requirement(&searched);
            let to_search = convert_to_requirement(&to_search);
            let expected = expected
                .into_iter()
                .map(|(start, end)| Range { start, end })
                .collect::<Vec<_>>();
            assert_eq!(get_compatible_ranges(&searched, &to_search), expected);
        }
        Ok(())
    }

    #[test]
    fn test_ordering_satisfy() -> Result<()> {
        let crude = vec![PhysicalSortExpr {
            expr: Arc::new(Column::new("a", 0)),
            options: SortOptions::default(),
        }];
        let finer = vec![
            PhysicalSortExpr {
                expr: Arc::new(Column::new("a", 0)),
                options: SortOptions::default(),
            },
            PhysicalSortExpr {
                expr: Arc::new(Column::new("b", 1)),
                options: SortOptions::default(),
            },
        ];
        // finer ordering satisfies, crude ordering shoul return true
        let empty_schema = &Arc::new(Schema::empty());
        let mut oeq_properties = OrderingEquivalenceProperties::new(empty_schema.clone());
        oeq_properties.oeq_group.push(finer.clone());
        assert!(oeq_properties.ordering_satisfy(Some(&crude)));

        // Crude ordering doesn't satisfy finer ordering. should return false
        let mut oeq_properties = OrderingEquivalenceProperties::new(empty_schema.clone());
        oeq_properties.oeq_group.push(crude.clone());
        assert!(!oeq_properties.ordering_satisfy(Some(&finer)));
        Ok(())
    }

    #[test]
    fn test_ordering_satisfy_with_equivalence() -> Result<()> {
        let col_a = &Column::new("a", 0);
        let col_b = &Column::new("b", 1);
        let col_c = &Column::new("c", 2);
        let col_d = &Column::new("d", 3);
        let col_e = &Column::new("e", 4);
        let col_f = &Column::new("f", 5);
        let col_g = &Column::new("g", 6);
        let option1 = SortOptions {
            descending: false,
            nulls_first: false,
        };
        let option2 = SortOptions {
            descending: true,
            nulls_first: true,
        };
        // The schema is ordered by a ASC NULLS LAST, b ASC NULLS LAST
        let (_test_schema, ordering_eq_properties) = create_test_params()?;
        // First element in the tuple stores vector of requirement, second element is the expected return value for ordering_satisfy function
        let requirements = vec![
            // `a ASC NULLS LAST`, expects `ordering_satisfy` to be `true`, since existing ordering `a ASC NULLS LAST, b ASC NULLS LAST` satisfies it
            (vec![(col_a, option1)], true),
            (vec![(col_a, option2)], false),
            // Test whether equivalence works as expected
            (vec![(col_c, option1)], true),
            (vec![(col_c, option2)], false),
            // Test whether ordering equivalence works as expected
            (vec![(col_d, option1)], true),
            (vec![(col_d, option1), (col_b, option1)], true),
            (vec![(col_d, option2), (col_b, option1)], false),
            (
                vec![(col_e, option2), (col_f, option1), (col_g, option1)],
                true,
            ),
            (vec![(col_e, option2), (col_f, option1)], true),
            (vec![(col_e, option1), (col_f, option1)], false),
            (vec![(col_e, option2), (col_b, option1)], false),
            (vec![(col_e, option1), (col_b, option1)], false),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_d, option1),
                    (col_b, option1),
                ],
                true,
            ),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_e, option2),
                    (col_f, option1),
                ],
                true,
            ),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_e, option2),
                    (col_b, option1),
                ],
                true,
            ),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_d, option2),
                    (col_b, option1),
                ],
                true,
            ),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_e, option1),
                    (col_f, option1),
                ],
                false,
            ),
            (
                vec![
                    (col_d, option1),
                    (col_b, option1),
                    (col_e, option1),
                    (col_b, option1),
                ],
                false,
            ),
            (vec![(col_d, option1), (col_e, option2)], true),
        ];

        for (cols, expected) in requirements {
            let err_msg = format!("Error in test case:{cols:?}");
            let required = cols
                .into_iter()
                .map(|(col, options)| PhysicalSortExpr {
                    expr: Arc::new(col.clone()),
                    options,
                })
                .collect::<Vec<_>>();

            let required = Some(&required[..]);
            assert_eq!(
                ordering_eq_properties.ordering_satisfy(required),
                expected,
                "{err_msg}"
            );
        }
        Ok(())
    }

    #[test]
    fn test_ordering_satisfy_different_lengths() -> Result<()> {
        let test_schema = create_test_schema()?;
        let col_a_expr = col("a", &test_schema)?;
        let col_b_expr = col("b", &test_schema)?;
        let col_c_expr = col("c", &test_schema)?;
        let col_d_expr = col("d", &test_schema)?;
        let col_e_expr = col("e", &test_schema)?;
        let col_f_expr = col("f", &test_schema)?;
        let option1 = SortOptions {
            descending: false,
            nulls_first: false,
        };
        // Column a and c are aliases.
        let mut ordering_eq_properties = OrderingEquivalenceProperties::new(test_schema);
        ordering_eq_properties.add_equal_conditions((&col_a_expr, &col_c_expr));

        // Column a and e are ordering equivalent (e.g global ordering of the table can be described both as a ASC and e ASC.)
        ordering_eq_properties.add_new_orderings(&[
            vec![PhysicalSortExpr {
                expr: col_a_expr.clone(),
                options: option1,
            }],
            vec![PhysicalSortExpr {
                expr: col_e_expr.clone(),
                options: option1,
            }],
        ]);

        // Column a and d,f are ordering equivalent (e.g global ordering of the table can be described both as [a ASC] and [d ASC, f ASC].)
        ordering_eq_properties.add_new_orderings(&[
            vec![PhysicalSortExpr {
                expr: col_a_expr.clone(),
                options: option1,
            }],
            vec![
                PhysicalSortExpr {
                    expr: col_d_expr.clone(),
                    options: option1,
                },
                PhysicalSortExpr {
                    expr: col_f_expr.clone(),
                    options: option1,
                },
            ],
        ]);
        // All of the orderings [a ASC], [d ASC, f ASC], [e ASC]]
        // are valid for the table
        // Also Columns a and c are equal

        let sort_req_a = PhysicalSortExpr {
            expr: col_a_expr.clone(),
            options: option1,
        };
        let sort_req_b = PhysicalSortExpr {
            expr: col_b_expr.clone(),
            options: option1,
        };
        let sort_req_c = PhysicalSortExpr {
            expr: col_c_expr.clone(),
            options: option1,
        };
        let sort_req_d = PhysicalSortExpr {
            expr: col_d_expr.clone(),
            options: option1,
        };
        let sort_req_e = PhysicalSortExpr {
            expr: col_e_expr.clone(),
            options: option1,
        };
        let sort_req_f = PhysicalSortExpr {
            expr: col_f_expr.clone(),
            options: option1,
        };

        assert!(ordering_eq_properties.ordering_satisfy_concrete(
            // After normalization would be a ASC
            &[sort_req_c.clone(), sort_req_a.clone(), sort_req_e.clone(),],
        ));
        assert!(!ordering_eq_properties.ordering_satisfy_concrete(
            // After normalization would be a ASC, b ASC
            // which is not satisfied
            &[sort_req_c.clone(), sort_req_b.clone(),],
        ));

        assert!(ordering_eq_properties.ordering_satisfy_concrete(
            // After normalization would be a ASC
            &[sort_req_c.clone(), sort_req_d.clone(),],
        ));

        assert!(!ordering_eq_properties.ordering_satisfy_concrete(
            // After normalization would be a ASC, b ASC
            // which is not satisfied
            &[sort_req_d.clone(), sort_req_f.clone(), sort_req_b.clone(),],
        ));

        assert!(ordering_eq_properties.ordering_satisfy_concrete(
            // After normalization would be a ASC
            // which is satisfied
            &[sort_req_d.clone(), sort_req_f.clone()],
        ));

        Ok(())
    }

    #[test]
    fn test_bridge_groups() -> Result<()> {
        let entries = vec![
            vec![lit(1), lit(2), lit(3)],
            vec![lit(2), lit(4), lit(5)],
            vec![lit(11), lit(12), lit(9)],
            vec![lit(7), lit(6), lit(5)],
        ];
        // Expected is a bit weird. However, what we care is they expected contains distinct groups.
        // where there is no common entry between any groups.
        // Since we do check for vector equality, this version should be used during comparison in the test.
        let expected = vec![
            vec![lit(11), lit(12), lit(9)],
            vec![lit(7), lit(6), lit(5), lit(2), lit(4), lit(1), lit(3)],
        ];
        let mut eq_groups = EquivalentGroups::new(entries);
        eq_groups.bridge_groups();

        let eq_groups = eq_groups.inner;
        assert_eq!(eq_groups.len(), expected.len());
        assert_eq!(eq_groups.len(), 2);

        assert!(physical_exprs_equal(&eq_groups[0], &expected[0]));
        assert!(physical_exprs_equal(&eq_groups[1], &expected[1]));
        Ok(())
    }

    #[test]
    fn test_remove_redundant_entries() -> Result<()> {
        let entries = vec![
            vec![lit(1), lit(1), lit(2)],
            // This group is meaningless should be removed
            vec![lit(3), lit(3)],
            vec![lit(4), lit(5), lit(6)],
        ];
        // Expected is a bit weird. However, what we care is they expected contains distinct groups.
        // where there is no common entry between any groups.
        // Since we do check for vector equality, this version should be used during comparison in the test.
        let expected = vec![vec![lit(1), lit(2)], vec![lit(4), lit(5), lit(6)]];
        let mut eq_groups = EquivalentGroups::new(entries);
        eq_groups.remove_redundant_entries();

        let eq_groups = eq_groups.inner;
        assert_eq!(eq_groups.len(), expected.len());
        assert_eq!(eq_groups.len(), 2);

        assert!(physical_exprs_equal(&eq_groups[0], &expected[0]));
        assert!(physical_exprs_equal(&eq_groups[1], &expected[1]));
        Ok(())
    }

    #[test]
    fn test_get_updated_right_ordering_equivalence_properties() -> Result<()> {
        let join_type = JoinType::Inner;

        let options = SortOptions::default();
        let right_oeq_class = OrderingEquivalentGroup::new(vec![
            vec![
                PhysicalSortExpr {
                    expr: Arc::new(Column::new("x", 0)),
                    options,
                },
                PhysicalSortExpr {
                    expr: Arc::new(Column::new("y", 1)),
                    options,
                },
            ],
            vec![
                PhysicalSortExpr {
                    expr: Arc::new(Column::new("z", 2)),
                    options,
                },
                PhysicalSortExpr {
                    expr: Arc::new(Column::new("w", 3)),
                    options,
                },
            ],
        ]);

        let left_columns_len = 4;

        let fields: Fields = ["a", "b", "c", "d", "x", "y", "z", "w"]
            .into_iter()
            .map(|name| Field::new(name, DataType::Int32, true))
            .collect();

        let schema = Schema::new(fields);
        let col_a_expr = col("a", &schema)?;
        let col_d_expr = col("d", &schema)?;
        let col_x_expr = col("x", &schema)?;
        let col_y_expr = col("y", &schema)?;
        let col_z_expr = col("z", &schema)?;
        let col_w_expr = col("w", &schema)?;

        let mut join_eq_properties = OrderingEquivalenceProperties::new(Arc::new(schema));
        join_eq_properties.add_equal_conditions((&col_a_expr, &col_x_expr));
        join_eq_properties.add_equal_conditions((&col_d_expr, &col_w_expr));

        let result = get_updated_right_ordering_equivalent_group(
            &join_type,
            &right_oeq_class,
            left_columns_len,
        )?;
        join_eq_properties.extend(result);
        let result = join_eq_properties.oeq_group().clone();

        let expected = OrderingEquivalentGroup::new(vec![
            vec![
                PhysicalSortExpr {
                    expr: col_a_expr,
                    options,
                },
                PhysicalSortExpr {
                    expr: col_y_expr,
                    options,
                },
            ],
            vec![
                PhysicalSortExpr {
                    expr: col_z_expr,
                    options,
                },
                PhysicalSortExpr {
                    expr: col_d_expr,
                    options,
                },
            ],
        ]);

        assert_eq!(result, expected);

        Ok(())
    }
}
